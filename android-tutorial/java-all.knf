=== [ linux:topic ][ jar ] ===
[ --- start ---- ]
[ jar ][ list classes ]
jar tf jar-file
[ ---  end  ---- ]

=== [ java:topic ][ general ] ===
[ --- start ---- ]
[ ---  end  ---- ]

=== [ java:topic ][ type ] ===
[ --- start ---- ]
Boolean (value is true or false)
null is null
[ ---  end  ---- ]

=== [ java:topic ][ random ] ===
[ --- start ---- ]
int random_max = 8;
/// return 0(inclusive)-random_max(exclusive)
/// in this example, will return 0-7
int randomIndex = random.nextInt(random_max); // random index
[ ---  end  ---- ]

=== [ java:topic ][ example random ] ===
[ --- start ---- ]
Collections.shuffle(fileNameList); // shuffle file names

// put the correct answer at the end of fileNameList
/// so fill in everything then replace one of it with answer
int correct = fileNameList.indexOf(correctAnswer);
fileNameList.add(fileNameList.remove(correct));

[ ---  end  ---- ]

=== [ java:topic ][ implement ] ===
[ --- start ---- ]
interface Bounceable{
	public void setBounce(int bounce);
	public int getBounce();
}

public class FootBall implements Bounceable{
	private int bounce;
	public void setBounce(int bounce){ this.bounce = bounce; }
	public int getBounce(){ return this.bounce; }
}

public class BaseBall implements Bounceable{
	private int bounce;
	public void setBounce(int bounce){ this.bounce = bounce; }
	public int getBounce(){ return this.bounce; }
}
[ ---  end  ---- ]

=== [ topic ][ extends vs implements ] ===
[ --- start ---- ]
- extends class
- cannot extends multiple classes 
- implements interface
- can implements multiple interfaces
- interface cannot have implementation of method
[ ---  end  ---- ]

=== [ topic ][ valueOf ] ===
[ --- start ---- ]
/// return the string value from various object type
import java.io.*;

public class Test{
   public static void main(String args[]){
      double d = 102939939.939;
      boolean b = true;
      long l = 1232874;
      char[] arr = {'a', 'b', 'c', 'd', 'e', 'f','g' };

      System.out.println("Return Value : " + String.valueOf(d) );
      System.out.println("Return Value : " + String.valueOf(b) );
      System.out.println("Return Value : " + String.valueOf(l) );
      System.out.println("Return Value : " + String.valueOf(arr) );
   }
}
[ ---  end  ---- ]

=== [ topic ][ switch ][ string ] ===
[ --- start ---- ]
public String getTypeOfDayWithSwitchStatement(String dayOfWeekArg) {
     String typeOfDay;
     switch (dayOfWeekArg) {
         case "Monday":
             typeOfDay = "Start of work week";
             break;
         case "Tuesday":
         case "Wednesday":
         case "Thursday":
             typeOfDay = "Midweek";
             break;
         case "Friday":
             typeOfDay = "End of work week";
             break;
         case "Saturday":
         case "Sunday":
             typeOfDay = "Weekend";
             break;
         default:
             throw new IllegalArgumentException("Invalid day of the week: " + dayOfWeekArg);
     }
     return typeOfDay;
}
[ ---  end  ---- ]

=== [ topic ][ return array ] ===
[ --- start ---- ]
public static String[]  pickString(int choice) {
	String pickedString[] = new String[3]; /// can't use local variable, need use new!
	pickedCipher[0]="strin1"; 
	return pickedString;
}
[ ---  end  ---- ]

=== [ topic ][ comment ] ===
[ --- start ---- ]
/* text */ - The compiler ignores everything from /* to */.
/** documentation */ -
This indicates a documentation comment (doc comment, for short). The compiler ignores this kind of comment, just like it ignores comments that use /* and */. The javadoc tool uses doc comments when preparing automatically generated documentation. For more information on javadoc, see the Javadocâ„¢ tool documentation .
// text - The compiler ignores everything from // to the end of the line.
[ ---  end  ---- ]

=== [ topic ][ try-catch ] ===
[ --- start ---- ]
public void callDivide(){
        try {
            int result = divide(2,1);
            System.out.println(result);
        } catch (BadNumberException e) {
            //do something clever with the exception
            System.out.println(e.getMessage());
        }
		/// always get executed
        System.out.println("Division attempt done");
    }
[ ---  end  ---- ]

=== [ topic ][ final ] ===
[ variable ]
[ --- start ---- ]
- must only initialized once!
- during declaration, it can be not yet initialized, then initialized later, but only once!
[ ---  end  ---- ]
